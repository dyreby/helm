# Vision

Helm is how I want to work with a coding agent.

## Why

I'm working on a [collaboration framework](https://github.com/dyreby/collaboration-framework) that started as a way to work better with a coding agent and evolved into something broader about narrowing the gap between intent and understanding. The concepts work. The philosophy holds. But the mechanism I was using (prompt extensions injected into an agent's system prompt) kept producing friction in the wrong places. The agent forgot to load concepts, worked around tool constraints, expanded scope silently, and made decisions I should have been making.

The root cause isn't the agent or the prompts. It's the architecture: an autonomous agent with tools is the wrong shape for how I want to collaborate with an LLM. I want to steer. I want the agent to advise. I want nothing to move without me.

Helm is a companion to the collaboration framework. Where the framework captures how I think about collaboration generally, Helm is how I put that into practice at a terminal with a coding agent.

## What

Helm is a TUI (terminal user interface) written in Rust and inspired by, among other things, John Boyd's OODA loop, Michael Singer's practice of serving the moment unfolding in front of us, and my dad's love of sailing. It's a personal tool, deeply shaped by how I think, tuned to my preferred way of working with a computer, and not trying to be general.

Helm delegates to external tools for specialized interaction and defines contracts for each (what context goes in, what artifact comes out). An LLM for generating positions, collaborating on plans, and drafting artifacts. An editor for reviewing and approving text before it leaves the system. Which tools fill those roles is a preference, not a dependency. I use [Helix](https://helix-editor.com/) and [pi](https://github.com/badlogic/pi-mono).

## Voyages

A voyage is a unit of work with a destination. "Review PR #128." "Fix bug: Safari login." "Implement feature: RBAC." Each voyage has an intent, a logbook, and an outcome.

When I launch Helm, I see my active voyages and can start a new one:

```
Helm

Active Voyages:
  1  Review PR #128       [Position]
  2  Fix Bug: Safari       [Bearing]

New Voyage:
  Review PR
  Investigate Issue
  Implement Feature
  Fix Bug
  ...
```

Each voyage type frames the first bearing. "Review PR" knows to survey PR metadata. "Implement Feature" might survey the repo structure and relevant files. After that initial bearing, every voyage follows the same loop.

Voyages are short by design. The ideal voyage is one command, a few steps, and a clean exit. Over time, most should converge toward: take bearing, decide on action, confirm, done.

## The Core Loop

Once inside a voyage, Helm presents actions in a menu that waits for me:

### Take Bearing

Observe the world and orient. Everything that follows depends on what's here.

Helm executes a `BearingPlan`, reading from the world across one or more domains (Files, GitHub, Search, Web, etc.). Each domain supports two levels of attention:

- **Survey** — broad scan. Show the lay of the land. Directory listings, PR metadata, search hit lists, response headers.
- **Inspect** — deepen selected items discovered by survey. Full file contents, complete diffs, comment thread bodies.

Survey always re-runs (fresh world read). Inspect targets are cumulative: I add and remove focus over successive bearings without losing the survey context.

The result is a `Bearing`: the plan that produced it, a `Moment` capturing what was observed, and a `Position`.

Position is a short, plain-text statement about the state of the world, generated by the agent from the full history of bearings in the voyage. A sentence or two, readable at a glance. It exists so that collaboration has a grounded starting point (the agent doesn't have to re-derive "what's going on" from raw evidence each time) and so the Logbook tells a readable story: scanning positions across bearings shows how the voyage unfolded without replaying moments.

Position defaults to a single generation. If it feels wrong, I can challenge it and the agent re-generates. But Position describes; it never prescribes.

Bearings are deterministic given the same plan and world state. Position is clearly labeled as agent-generated interpretation.

### Correct Position

Refine the agent's read on the situation. Sometimes the position is wrong, or it misses something I know. I can challenge it, add context ("that CI failure is a flake"), or guide the agent toward a more accurate statement.

This can involve conversation, editing, or both. The goal is a Position I trust before deciding what to do next.

### Correct Course

Decide what to do and shape how to do it. This is where collaboration happens: I talk with the agent about approach, review drafts, iterate on tone, make edits in Helix, ask the agent to refine what I wrote. Conversation and editing interleave in whatever order makes sense.

The agent can see the current bearing and the history of all `BearingPlan`s, but never old snapshot content. If it needs something from a prior scope, it must propose a new bearing.

This phase ends when I have either a new `BearingPlan` (take another bearing) or an `ActionPlan` (ready to act). If the result is a new `BearingPlan`, Helm immediately takes that bearing and returns to the menu with an updated position.

Conversations during this phase are ephemeral. They may be persisted later for improvement purposes, but they are not required for correctness and are not part of the durable logbook.

### Take Action

Affect the world. This is the only phase where changes can't be taken back.

An `ActionPlan` describes intent: post a review, open a PR, apply a patch, create or edit or delete files. Before execution, I approve through a gate:

- **Helix** for text artifacts. The review body, PR description, or report opens in my editor. I read, edit if needed, and close to proceed.
- **Yes/No prompt** for irreversible operations.

The result is an `ActionReport`, which always contains the `ActionPlan` that produced it. No orphaned intents.

## The Logbook

A voyage's logbook is an append-only sequence of `Bearing`s and `ActionReport`s.

Nothing is overwritten. Nothing is dropped. Each bearing is an immutable record of plan + moment + position. Each action report is an immutable record of plan + outcome.

Voyages can be paused and resumed. When I return, the world may have changed. I trigger a new bearing ("the world changed", "the world might have changed", or "I have new understanding"). Old bearings remain as history; the latest bearing is the active ground truth.

Logbook data lives locally on each machine. It is not committed to the repo, not synced across devices, and not shared with the agent beyond what's explicitly included in the current bearing.

Bearings persist as two layers:
- **Records** (always): plan + position + summary of what changed
- **Moments** (recent): raw observed payloads, kept for recent bearings

## Source Kinds

A `BearingPlan` contains one or more source kinds. Each kind is a domain of observable reality, not a mechanism. Commands are how Helm fetches data; kinds describe what Helm is looking at.

The starting set:

- **Files** — filesystem structure and content. Survey returns directory trees with metadata. Inspect returns file contents.
- **GitHub** — PRs, issues, checks, comments, repos. Survey returns metadata, file lists, check summaries. Inspect returns full diffs, comment bodies, thread details.
- **Web** — any remote resource fetched over HTTP. Survey returns status and headers. Inspect returns response bodies.
- **Search** — pattern matching across text sources. Survey returns file/location hit lists. Inspect returns matches with context.

Web-based kinds graduate to their own domain when their scope/focus semantics are rich enough to warrant it. GitHub is the first domain that graduated.

### Open question: Search as a cross-cutting kind

Search naturally targets other kinds: you search *files*, or search *GitHub comments*. The other kinds are independent domains. Whether Search is a peer kind or something that layers on top of other kinds is unresolved. For now it's a peer, because it works and avoids premature abstraction.

## Scope and Focus

Inside each source kind, a `BearingPlan` describes attention using two concepts:

- **Scope** — collections to survey (directories, PRs, URLs)
- **Focus** — specific items within scope to inspect

Modeled as a map from scope targets to an optional set of focus items. No focus means survey-only. Focus means inspect those items (in addition to surveying the scope). A generic container keeps this consistent across kinds while allowing type-safe scope/focus per domain.

Plans are always immutable. Survey produces a fresh moment. Inspect adds focus items cumulatively; I can also unfocus items. Each change produces a new immutable plan and a new bearing.

## The Agent Contract

The agent is stateless. Every call receives explicit context and returns a structured proposal. No ongoing session. No hidden memory.

During **Take Bearing**, the agent receives the full history of bearings (plans + positions, not old moments) and produces a Position string. Short, bounded, descriptive. It may reference historical trends if clearly relevant; otherwise it ignores history. Position describes; it never prescribes. I can challenge the position if it's wrong, and the agent re-generates.

During **Correct Course**, the agent receives the current bearing, plan history, and constraints. It must return exactly one of: a new `BearingPlan`, an `ActionPlan`, or an abort. The conversation is bounded by this requirement.

The agent never executes tools. The agent never sees old moment data. The agent never expands scope without my approval. These are structural constraints, not instructions.

## Key Concepts

Names that drive the design.

| Name | Role |
|------|------|
| **Voyage** | A unit of work with intent, logbook, and outcome |
| **Logbook** | Append-only voyage history |
| **Bearing** | Immutable record: plan + moment + position |
| **BearingPlan** | What to observe, at what scope/focus |
| **Moment** | What was observed, with enough metadata to detect change from a previous bearing |
| **Position** | Short text statement of world state (agent-generated) |
| **ActionPlan** | Intent to affect the world |
| **ActionReport** | Outcome of action, contains its plan |
| **Source kinds** | Domains of observable reality |
| **Scope / Focus** | Data model for survey/inspect attention |
| **Survey / Inspect** | UI actions for breadth/depth |

## Design Principles

- **Plans describe what to observe, not how to observe it.** Kinds are domains of reality. Commands are implementation.
- **Bearings are always fresh.** Survey re-runs every time. No stale catalog reuse.
- **The agent proposes; Helm enforces; I approve.** Authority without autonomy.
- **Immutable history, append-only log.** Nothing is overwritten or dropped.
- **Old moments are never reused by the agent.** If it needs past data, it proposes a new bearing.
- **Voyages are local.** No syncing, no shared state, no committed artifacts.
- **Bring your own tools.** Helm orchestrates; external tools do the specialized work. The editor, the conversational agent, and future integrations are all pluggable.
- **Joy matters.** This is a daily tool. The language, the flow, and the rhythm should feel intentional and calm.

## What This Document Is Not

- **Not an implementation plan.** The types and flows described here are the conceptual architecture. Implementation will emerge through building Helm with Helm.
- **Not a general framework.** Helm is shaped by how I think. Others may find it interesting; that's a side effect, not a goal.
- **Not an autonomous agent.** The agent never drives. It advises within hard constraints. The helm waits for me.
