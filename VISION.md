# Vision

Helm is how I want to work with a coding agent.

## Why

I'm working on a [collaboration framework](https://github.com/dyreby/collaboration-framework) that started as a way to work better with a coding agent and evolved into something broader about narrowing the gap between intent and understanding. The concepts work. The philosophy holds. But the mechanism I was using (prompt extensions injected into an agent's system prompt) kept producing friction in the wrong places. The agent forgot to load concepts, worked around tool constraints, expanded scope silently, and made decisions I should have been making.

The root cause isn't the agent or the prompts. It's the architecture: an autonomous agent with tools is the wrong shape for how I want to collaborate. I want to steer. I want the agent to advise. I want nothing to move without me.

Helm is a companion to the collaboration framework. Where the framework defines *how I think about collaboration*, Helm defines *how I practice it*: a terminal interface backed by an LLM.

## What

Helm is a Rust TUI (ratatui) built around the OODA loop. It's a personal tool, deeply shaped by how I think, tuned to my intervention style, and not trying to be general.

The agent is a stateless reasoning coprocessor. Any LLM that can receive structured context and return structured proposals will work. Helm doesn't depend on a specific coding agent; it needs a thin interface for sending prompts and parsing responses. The agent proposes. Helm enforces. I approve. No tool autonomy. No hidden state. No silent scope expansion.

Helm delegates specialized interaction to external tools. An editor for reviewing and approving text artifacts. A conversational agent for the collaboration phase. Which tools those are is a preference, not a dependency. Helm defines the contracts (what context goes in, what artifact comes out) and lets you bring what you like. I use [Helix](https://helix-editor.com/) and [pi](https://github.com/badlogic/pi-mono).

Sessions are short by design. The ideal session is one command, a few steps, and a clean exit. Over time, most runs should converge toward: take bearing, decide on action, confirm, done.

## The Core Loop

Helm presents three actions in a menu that waits for me:

### Take Bearing

Observe the world and orient. Everything that follows depends on what's here.

Helm executes a `BearingPlan`, reading from the world across one or more domains (Files, GitHub, Search, Web, etc.). Each domain supports two levels of attention:

- **Survey** — broad scan. Show the lay of the land. Directory listings, PR metadata, search hit lists, response headers.
- **Inspect** — deepen selected items discovered by survey. Full file contents, complete diffs, comment thread bodies.

Survey always re-runs (fresh world read). Inspect targets are cumulative: I add and remove focus over successive bearings without losing the survey context.

The result is a `Bearing`: the plan that produced it, a `Moment` capturing what was observed, and a `Position`.

Position is a short, plain-text statement about the state of the world, generated by the agent from the full history of bearings in the session. A sentence or two, readable at a glance. It exists so that Correct Course has a grounded starting point (the agent doesn't have to re-derive "what's going on" from raw evidence each time) and so the Logbook tells a readable story: scanning positions across bearings shows how the situation evolved without replaying snapshots.

Position is the one place the agent's interpretation enters during this phase, and it defaults to a single generation. If the position feels wrong, I can challenge it and the agent re-generates. But Position describes; it never prescribes.

Bearings are deterministic given the same plan and world state. Position is clearly labeled as agent-generated interpretation.

### Correct Course

The only conversational phase.

I interact with the agent, grounded in the latest Bearing. The agent can see the current bearing and the history of all `BearingPlan`s, but never old snapshot content. If it needs something from a prior scope, it must propose a new bearing. The conversation is bounded: it must end with either a new `BearingPlan` or an `ActionPlan`.

If the result is a new `BearingPlan`, Helm immediately takes that bearing (it's reversible, no side effects) and returns to the menu with an updated position.

The conversation itself is ephemeral. It may be persisted later for improvement purposes, but it is not required for correctness and is not part of the durable session record.

### Take Action

Affect the world. This is the only phase with side effects.

An `ActionPlan` describes intent: post a review, open a PR, apply a patch, create or edit or delete files. Before execution, I approve through a gate:

- **Helix** for text artifacts. The review body, PR description, or report opens in my editor. I read, edit if needed, and close to proceed.
- **Yes/No prompt** for irreversible operations.

The result is an `ActionReport`, which always contains the `ActionPlan` that produced it. No orphaned intents.

## The Logbook

A session is an append-only sequence of `Bearing`s and `ActionReport`s. That's the `Logbook`.

Nothing is overwritten. Nothing is dropped. Each bearing is an immutable record of plan + moment + position. Each action report is an immutable record of plan + outcome.

Sessions can be paused and resumed. When I return to a session, the world may have changed. I trigger a new bearing ("the world changed", "the world might have changed", or "I have new understanding"). Old bearings remain as history; the latest bearing is the active ground truth.

Session data lives locally on each machine. It is not committed to the repo, not synced across devices, and not shared with the agent beyond what's explicitly included in the current bearing.

Bearings persist as two layers:
- **Records** (always): plan + world stamps + position + delta summary
- **Snapshots** (recent): raw observed payloads, kept for recent bearings

## Source Kinds

A `BearingPlan` contains one or more source kinds. Each kind is a domain of observable reality, not a mechanism. Commands are how Helm fetches data; kinds describe what Helm is looking at.

The starting set:

- **Files** — filesystem structure and content. Survey returns directory trees with metadata. Inspect returns file contents.
- **GitHub** — PRs, issues, checks, comments, repos. Survey returns metadata, file lists, check summaries. Inspect returns full diffs, comment bodies, thread details.
- **Web** — any remote resource fetched over HTTP. Survey returns status and headers. Inspect returns response bodies.
- **Search** — pattern matching across text sources. Survey returns file/location hit lists. Inspect returns matches with context.

Kinds start in Web and graduate to their own domain when their scope/focus semantics are rich enough to warrant it. GitHub is the first domain that graduated.

### Open question: Search as a cross-cutting kind

Search naturally targets other kinds: you search *files*, or search *GitHub comments*. The other kinds are independent domains. Whether Search is a peer kind or something that layers on top of other kinds is unresolved. For now it's a peer, because it works and avoids premature abstraction.

## Scope and Focus

Inside each source kind, a `BearingPlan` describes attention using two concepts:

- **Scope** — collections to survey (directories, PRs, URLs)
- **Focus** — specific items within scope to inspect

Modeled as a map from scope targets to an optional set of focus items. No focus means survey-only. Focus means inspect those items (in addition to surveying the scope). A generic container keeps this consistent across kinds while allowing type-safe scope/focus per domain.

Plans are always immutable. Survey produces a fresh snapshot. Inspect adds focus items cumulatively; I can also unfocus items. Each change produces a new immutable plan and a new bearing.

## The Agent Contract

The agent is stateless. Every call receives explicit context and returns a structured proposal. No ongoing session. No hidden memory.

During **Take Bearing**, the agent receives the full history of bearings (plans + positions, not old snapshots) and produces a Position string. Short, bounded, descriptive. It may reference historical trends if clearly relevant; otherwise it ignores history. Position describes; it never prescribes. I can challenge the position if it's wrong, and the agent re-generates.

During **Correct Course**, the agent receives the current bearing, plan history, and constraints. It must return exactly one of: a new `BearingPlan`, an `ActionPlan`, or an abort. The conversation is bounded by this requirement.

The agent never executes tools. The agent never sees old snapshot content. The agent never expands scope without my approval. These are structural constraints, not instructions.

## Key Concepts

Names that drive the design. These are the current best names; some are settled, some may evolve.

| Name | Role | Status |
|------|------|--------|
| **Logbook** | Append-only session history | Settled |
| **Bearing** | Immutable record: plan + moment + position | Settled |
| **BearingPlan** | What to observe, at what scope/focus | Settled |
| **Moment** | Captured observed data + world stamps | Settled |
| **Position** | Short text statement of world state (agent-generated) | Settled |
| **ActionPlan** | Intent to affect the world | Settled |
| **ActionReport** | Outcome of action, contains its plan | Settled |
| **Source kinds** | Domains of observable reality | Settled as a concept; individual kinds will evolve |
| **Scope / Focus** | Data model for survey/inspect attention | Settled |
| **Survey / Inspect** | UI actions for breadth/depth | Settled |
| **Course** | The conversational collaboration phase | Open — might not need a formal type |

## Design Principles

- **Plans describe what to observe, not how to observe it.** Kinds are domains of reality. Commands are implementation.
- **Bearings are always fresh.** Survey re-runs every time. No stale catalog reuse.
- **The agent proposes; Helm enforces; I approve.** Authority without autonomy.
- **Immutable history, append-only log.** Nothing is overwritten or dropped.
- **Old snapshot content is never reused by the agent.** If it needs past data, it proposes a new bearing.
- **Sessions are local.** No syncing, no shared state, no committed artifacts.
- **Bring your own tools.** Helm orchestrates; external tools do the specialized work. The editor, the conversational agent, and future integrations are all pluggable.
- **Joy matters.** This is a daily tool. The language, the flow, and the rhythm should feel intentional and calm.

## What This Document Is Not

- **Not an implementation plan.** The types and flows described here are the conceptual architecture. Implementation will emerge through building Helm with Helm.
- **Not a general framework.** Helm is shaped by how I think. Others may find it interesting; that's a side effect, not a goal.
- **Not an autonomous agent.** The agent never drives. It advises within hard constraints. The helm waits for me.
